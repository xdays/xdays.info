---
title: arp欺骗过程
date: 2010-06-06
author: admin
category: protocol
tags: ['protocol']
slug: arp欺骗过程
---

转自:http://baike.baidu.com/view/726493.htm?fr=ala0

假设一个只有三台电脑组成的局域网，该局域网由交换机(Switch)连接。其中一个电脑名叫 A，代表攻击方；一台电脑叫 S，代表源主机，即发送数据的电脑；令一台电脑名叫 D，代表目的主机，即接收数据的电脑。这三台电脑的 IP 地址分别为 192.168.0.2，192.168.0.3，192.168.0.4。MAC 地址分别为 MAC_A，MAC_S，MAC_D。

现在，S 电脑要给 D 电脑发送数据了，在 S 电脑内部，上层的 TCP 和 UDP 的数据包已经传送到了最底层的网络接口层，数据包即将要发送出去，但这时还不知道目的主机 D 电脑的 MAC 地址 MAC_D。这时候，S 电脑要先查询自身的 ARP 缓存表，查看里面是否有 192.168.0.4 这台电脑的 MAC 地址，如果有，那很好办，就将
封装在数据包的外面。直接发送出去即可。如果没有，这时 S 电脑要向全网络发送一个 ARP 广播包，大声询问：“我的 IP 是 192.168.0.3，硬件地址是 MAC_S，我想知道 IP 地址为 192.168.0.4 的主机的硬件地址是多少？”
这时，全网络的电脑都收到该 ARP 广播包了，包括 A 电脑和 D 电脑。A 电脑一看其要查询的 IP 地址不是自己的，就将该数据包丢弃不予理会。而 D 电脑一看 IP 地址是自己的，则回答 S 电脑：“我的 IP 地址是 192.168.0.4，我的硬件地址是 MAC_D”需要注意的是，这条信息是单独回答的，即 D 电脑单独向 S 电脑发送的，并非刚才的广播。现在 S 电脑已经知道目的电脑 D 的 MAC 地址了，它可以将要发送的数据包上贴上目的地址 MAC_D，发送出去了。同时它还会动态更新自身的 ARP 缓存表，将 192.168.0.4－MAC_D 这一条记录添加进去，这样，等 S 电脑下次再给 D 电脑发送数据的时候，就不用大声询问发送 ARP 广播包了。这就是正常情况下的数据包发送过程。

这样的机制看上去很完美，似乎整个局域网也天下太平，相安无事。但是，上述数据发送机制有一个致命的缺陷，即它是建立在对局域网中电脑全部信任的基础上的，也就是说它的假设前提是：无论局域网中那台电脑，其发送的 ARP 数据包都是正确的。那么这样就很危险了！因为局域网中并非所有的电脑都安分守己，往往有非法者的存在。比如在上述数据发送中，当 S 电脑向全网询问“我想知道 IP 地址为 192.168.0.4 的主机的硬件地址是多少？”后，D 电脑也回应了自己的正确 MAC 地址。但是当此时，一向沉默寡言的 A 电脑也回话了：“我的 IP 地址是 192.168.0.4，我的硬件地址是 MAC_A”
，注意，此时它竟然冒充自己是 D 电脑的 IP 地址，而 MAC 地址竟然写成自己的！由于 A 电脑不停地发送这样的应答数据包，本来 S 电脑的 ARP 缓存表中已经保存了正确的记录：192.168.0.4－MAC_D，但是由于 A 电脑的不停应答，这时 S 电脑并不知道 A 电脑发送的数据包是伪造的，导致 S 电脑又重新动态更新自身的 ARP 缓存表，这回记录成：192.168.0.4－MAC_A，很显然，这是一个错误的记录（这步也叫 ARP 缓存表中毒），这样就导致以后凡是 S 电脑要发送给 D 电脑，也就是 IP 地址为 192.168.0.4 这台主机的数据，都将会发送给 MAC 地址为 MAC_A 的主机，这样，在光天化日之下，A 电脑竟然劫持了由 S 电脑发送给 D 电脑的数据！这就是 ARP 欺骗的过程。
